---
title: "常见算法总结"
date: 2023-01-09T10:29:45+08:00
tags: []
categories: [数据结构与算法]
draft: false
---

## 常见算法总结

### Floyd 判圈算法

Floyd判圈算法(Floyd Cycle Detection Algorithm)，又称龟兔赛跑算法(Tortoise and Hare Algorithm)，是一个可以在有限状态机、迭代函数或者链表上判断是否存在环，求出该环的起点与长度的算法。该算法据高德纳称由美国科学家罗伯特·弗洛伊德发明，但这一算法并没有出现在罗伯特·弗洛伊德公开发表的著作中。
如果有限状态机、迭代函数或者链表上存在环，那么在某个环上以**不同速度**前进的2个指针必定会在某个时刻相遇。同时显然地，如果从同一个起点(即使这个起点不在某个环上)同时开始以不同速度前进的2个指针最终相遇，那么可以判定存在一个环，且可以求出二者相遇处所在的环的起点与长度。



#### 算法描述

##### 判断是否存在环路

如果有限状态机、迭代函数或者链表存在环，那么一定存在一个起点可以到达某个环的某处(这个起点也可以在某个环上)。
初始状态下，假设已知某个起点节点为节点S。现设两个指针t和h，将它们均指向S。接着，同时让t和h往前推进，但是二者的速度不同：t每前进1步，h前进2步。只要二者都可以前进而且没有相遇，就如此保持二者的推进。当h无法前进，即到达某个没有后继的节点时，就可以确定从S出发不会遇到环。反之当t与h再次相遇时，就可以确定从S出发一定会进入某个环，设其为环C。如果确定了存在某个环，就可以求此环的起点与长度。

##### 求解环路的长度

上述算法刚判断出存在环C时，显然t和h位于同一节点，设其为节点M。显然，仅需令h不动，而t不断推进，最终又会返回节点M，统计这一次t推进的步数，显然这就是环C的长度。

##### 求解环路的起点

为了求出环C的起点，只要令h仍均位于节点M，而令t移动至起点节点S，此时h与t之间距为环C长度的整数倍。随后，同时让t和h往前推进，且保持二者的速度相同：t每前进1步，h前进1步。持续该过程直至t与h再一次相遇，设此次相遇时位于同一节点P，则节点P即为从节点S出发所到达的环C的第一个节点，即环C的一个起点。

**对于环路起点算法的解释：**

![img](https://raw.githubusercontent.com/liuhaibin123456789/img-for-cold-bin-blog/master/img/Floyd%20%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95.png)

假设出发起点到环起点的距离为`m`，已经确定有环，环的周长为`n`，（第一次）相遇点距离环的起点的距离是`k`。那么当两者相遇时，慢指针（t）移动的总距离`i = m + a * n + k`，快指针（h）的移动距离为`2i`，`2i = m + b * n + k`。其中，`a`和`b`分别为`t`和`h`在第一次相遇时转过的圈数。让两者相减（快减慢），那么有`i = (b - a) * n`。即`i`是圈长度的倍数，`b*n`和`a*n`都是环长度的倍数。



​	    **`i=(b-a)*n = m+a*n+k` ==> `3i = b*n+i+m+k = m+k+i` ==> `2i = m+k`，所以得出`m+k`是环长的整数倍**



将一个指针移到出发起点S，另一个指针仍呆在相遇节点M处，两者同时移动，每次移动一步。当第一个指针前进了`m`，即到达环起点时，另一个指针距离链表起点为`m+k `。考虑到`m+k`为圈长度的倍数，可以理解为指针从链表起点出发，走到环起点，然后绕环转了几圈，所以第二个指针也必然在环的起点。即两者相遇点就是环的起点。



**伪代码：**

```txt
t := &S
h := &S                                        //令指针t和h均指向起点节点S。
repeat
    t := t->next
    h := h->next
    if h is not NULL                                //要注意这一判断一般不能省略
            h := h->next
until t = h or h = NULL
if h != NULL                                       //如果存在环的话
    n := 0
    repeat                                              //求环的长度
            t := t->next
            n := n+1
    until t = h
    t := &S                                     //求环的一个起点
    while t != h
            t := t->next
            h := h->next
    P := *t
```



**算法复杂度**

- **时间复杂度：**注意到当指针t到达环C的一个起点节点P时(此时指针h显然在环C上)，之后指针t最多仅可能走1圈。若设节点S到P距离为 m，环C的长度为  n，则时间复杂度为 O(m+n)，是线性时间的算法。

- **空间复杂度：**仅需要创立指针t、指针h，保存环长n、环的一个起点P。空间复杂度为 O(1)，是常数空间的算法

### KMP算法

博客参考 => [很详尽的KMP算法](https://www.cnblogs.com/zzuuoo666/p/9028287.html)&[详解KMP中next数组求解](https://www.cnblogs.com/aninock/p/13796006.html)

#### 暴力匹配算法

假设现在我们面7899临这样一个问题：有一个0410文本串`S`，和一个模式串`P`，现在要查找`P`在`S`中的位置，怎么查找呢？

  如果用暴力匹配的思路，并假设现在文本串S匹配到 `i` 位置，模式串P匹配到 `j` 位置，则有：

- 如果当前字符匹配成功（即`S[i] == P[j]`），则`i++`，`j++`，继续匹配下一个字符；
- 如果失配（即`S[i]! = P[j]`），令`i = i - (j - 1)`，`j = 0`。相当于每次匹配失败时，`i`回溯到下一个字符，`j`被置为`0`。

暴力匹配算法咋一看好像也没啥，能解决问题。但是如果需要匹配的字符串重复字符太多的话会发生什么呢？

例如，文本串`txt=BBC ABCDAB ABCDABCDABDE`，子串`p=ABCDABD`。

#### KMP算法

在上面那个例子里，如果采用暴力匹配时，每次子串`p`匹配失败时，都会使得文本串`txt`回溯到下一个字符，显然这样回溯时间复杂度很高，而且可以发现其实我们没必要回溯到下一个字符，也就是要减少匹配的趟数。

那么，如何减少匹配的趟数呢？其实在每一次匹配过程中，我们就能够判断后续几次匹配是否会成功，算法的核心就是**每次匹配过程中推断出后续完全不可能匹配成功的匹配过程**，从而减少比较的趟数，如图所示：

![动图](https://pic3.zhimg.com/v2-f917fb03305a122847eff23b283700c2_b.webp)



因此，第一次匹配过之后，就可以得出可以直接跳到第四趟再进行判断的结论了。因为第一次匹配的时候，前5个序列和主串相同，只需要对模式串进行分析，模式串出现了重复单元(即AB)，在第一次匹配失败后就可以直接跳跃到出现重复单元的位置。

![img](https://pic1.zhimg.com/80/v2-cad29d897f52a03463362753f1563280_1440w.webp)

**next数组**

next数组实质上就是找出**模式串中前后字符重复出现的个数**，为了能够跳跃不可能匹配的步骤。
next数组的定义为：next[i]表示模式串A[0]至A[i]这个字串，使得前k个字符等于后k个字符的最大值，特别的k不能取i+i,因为字串一共才i+1个字符，自己跟自己相等毫无意义。

![动图封面](https://pic2.zhimg.com/v2-b2671ed95403cd88a5a71d893d29a0cd_b.jpg)

最终得到next数组为：

![img](https://pic1.zhimg.com/80/v2-2b2ac606c9aa62459be0a7320eac7218_1440w.webp)

如何确定在移动过程中需要跳过多少步呢？下图更直观的体现了跳跃的过程：

![img](https://pic1.zhimg.com/80/v2-f225476d948d9c1ac21c8dd1ddf705e0_1440w.webp)

对于上述红色部分的计算跳过长度的公式为**跳过的趟数=匹配上字符串中间字符长度-重复字符串长度**

![img](https://pic2.zhimg.com/80/v2-850ae8da2887132894116c6220de3e01_1440w.webp)

跳过这些步骤后**并非再从头开始匹配**，而是**从重复位置开始匹配**：

![img](https://pic2.zhimg.com/80/v2-49a5aa24121290d74f2a89a4c3eb5d75_1440w.webp)

最终，我们不难得出如下结论：

![img](https://pic1.zhimg.com/80/v2-dc01527ede39a513b3663b0aaa0b718c_1440w.webp)

### 快速幂算法

#### 递归思想

「快速幂算法」的本质是分治算法。举个例子，如果我们要计算 x^64^，我们可以按照：
$$
x \to x^2 \to x^4 \to x^8 \to x^{16} \to x^{32} \to x^{64}
$$
的顺序，从 x 开始，每次直接把上一次的结果进行平方，计算 66 次就可以得到 x^64^ 的值，而不需要对 x 乘 63 次 x。

再举一个例子，如果我们要计算 x^77^，我们可以按照：
$$
x \to x^2 \to x^4 \to x^9 \to x^{19} \to x^{38} \to x^{77}
$$
的顺序，在 $$x \to x^2，x^2 \to x^4，x^{19} \to x^{38}$$ 这些步骤中，我们直接把上一次的结果进行平方，而在 $$x^4 \to x^9，x^9 \to x^{19}，x^{38} \to x^{77}$$ 这些步骤中，我们把上一次的结果进行平方后，还要额外乘一个 x。

直接从左到右进行推导看上去很困难，因为在每一步中，我们不知道在将上一次的结果平方之后，还需不需要额外乘 x。但如果我们从右往左看，分治的思想就十分明显了：

- 当我们要计算 x^n^ 时，我们可以先递归地计算出 $$y = x^{\lfloor n/2 \rfloor}$$，其中 $$\lfloor a \rfloor$$ 表示对 a 进行下取整；
- 根据递归计算的结果，如果 n 为偶数，那么 x^n^ = y^2^；如果 n 为奇数，那么 x^n^ = y^2^ ；
- 递归的边界为 n = 0，任意数的 0 次方均为 1。

由于每次递归都会使得指数减少一半，因此递归的层数为 O(log n)，算法可以在很快的时间内得到结果。

```java
class Solution {
    public double myPow(double x, int n) {
        long N = n;
        return N >= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);
    }

    public double quickMul(double x, long N) {
        if (N == 0) {
            return 1.0;
        }
        double y = quickMul(x, N / 2);
        return N % 2 == 0 ? y * y : y * y * x;
    }
}
```

**复杂度分析**

- 时间复杂度：O(log n)，即为递归的层数。
- 空间复杂度：O(log n)，即为递归的层数。这是由于递归的函数调用会使用栈空间。

#### 迭代思想

由于递归需要使用额外的栈空间，我们试着将递归转写为迭代。在方法一中，我们也提到过，从左到右进行推导是不容易的，因为我们不知道是否需要额外乘 x。但我们不妨找一找规律，看看哪些地方额外乘了 x，并且它们对答案产生了什么影响。

我们还是以 x^77^ 作为例子：
$$
x \to x^2 \to x^4 \to^+ x^9 \to^+ x^{19} \to x^{38} \to^+ x^{77}
$$
并且把需要额外乘 x 的步骤打上了 + 标记。可以发现：

- $$x^{38} \to^+ x^{77}$$ 中额外乘的 x 在 x^77^ 中贡献了 x；
- $$x^9 \to^+ x^{19}$$ 中额外乘的 x 在之后被平方了 2 次，因此在 x^77^ 中贡献了 $$x^{2^2} = x^4$$；
- $$x^4 \to^+ x^9$$ 中额外乘的 x 在之后被平方了 3 次，因此在 x^77^ 中贡献了 $$x^{2^3} = x^8$$；
- 最初的 x 在之后被平方了 6 次，因此在 x^77^ 中贡献了 $$x^{2^6} = x^{64}$$。

我们把这些贡献相乘，$$x \times x^4 \times x^8 \times x^{64}$$ 恰好等于 x^77^。而这些贡献的指数部分又是什么呢？它们都是 2 的幂次，这是因为每个额外乘的 x 在之后都会被平方若干次。而这些指数 1，4，8 和 64，**恰好就对应了 77 的二进制表示 (1001101)~2~ 中的每个 1！

因此我们借助整数的二进制拆分，就可以得到迭代计算的方法，一般地，如果整数 n 的二进制拆分为
$$
n = 2^{i_0} + 2^{i_1} + \cdots + 2^{i_k}
$$
那么
$$
x^n = x^{2^{i_0}} \times x^{2^{i_1}} \times \cdots \times x^{2^{i_k}}
$$
这样以来，我们从 x 开始不断地进行平方，得到 $$x^2, x^4, x^8, x^{16}, \cdots$$，如果 n 的第 k 个（从右往左，从 0 开始计数）二进制位为 1，那么我们就将对应的贡献 $$x^{2^k}$$计入答案。

下面的代码给出了详细的注释。

```java
class Solution {
    public double myPow(double x, int n) {
        long N = n;
        return N >= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);
    }

    public double quickMul(double x, long N) {
        double ans = 1.0;
        // 贡献的初始值为 x
        double x_contribute = x;
        // 在对 N 进行二进制拆分的同时计算答案
        while (N > 0) {
            if (N % 2 == 1) {
                // 如果 N 二进制表示的最低位为 1，那么需要计入贡献
                ans *= x_contribute;
            }
            // 将贡献不断地平方
            x_contribute *= x_contribute;
            // 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可
            N /= 2;
        }
        return ans;
    }
}
```
